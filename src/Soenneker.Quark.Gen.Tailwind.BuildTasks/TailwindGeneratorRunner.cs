using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using Soenneker.Blazor.Utils.ComponentHtmlRenderers;
using Soenneker.Node.Util.Abstract;
using Soenneker.Quark.Gen.Tailwind.BuildTasks.Abstract;
using Soenneker.Utils.CommandLineArgs.Abstract;
using Soenneker.Utils.Process.Abstract;

namespace Soenneker.Quark.Gen.Tailwind.BuildTasks;

/// <inheritdoc cref="ITailwindGeneratorRunner"/>
public sealed class TailwindGeneratorRunner : ITailwindGeneratorRunner
{
    private readonly INodeUtil _nodeUtil;
    private readonly IProcessUtil _processUtil;
    private readonly ICommandLineArgsUtil _commandLineArgsUtil;

    public TailwindGeneratorRunner(INodeUtil nodeUtil, IProcessUtil processUtil, ICommandLineArgsUtil commandLineArgsUtil)
    {
        _nodeUtil = nodeUtil;
        _processUtil = processUtil;
        _commandLineArgsUtil = commandLineArgsUtil;

    }
    private const string GeneratedContentFileName = "TailwindElements.txt";
    private const string TailwindDirName = "tailwind";
    /// <summary>Output path for Tailwind CLI relative to the tailwind directory. Override with --tailwindOutput or MSBuild TailwindOutput.</summary>
    private const string DefaultTailwindOutputRelative = "../wwwroot/css/quark-tailwind.css";

    /// <summary>Regex to extract tag name and class value from elements: &lt;tag ... class="..." ...&gt;</summary>
    private static readonly Regex ElementWithClassRegex = new(
        @"<(\w+)[^>]*\bclass\s*=\s*[""']([^""']*)[""'][^>]*>",
        RegexOptions.Compiled | RegexOptions.CultureInvariant);

    public async ValueTask<int> Run(CancellationToken cancellationToken = default)
    {
        if (!_commandLineArgsUtil.TryGet("--targetPath", out string? targetPath) || string.IsNullOrWhiteSpace(targetPath))
            return Fail("Missing required --targetPath");
        if (!_commandLineArgsUtil.TryGet("--projectDir", out string? projectDir) || string.IsNullOrWhiteSpace(projectDir))
            return Fail("Missing required --projectDir");

        targetPath = Path.GetFullPath(targetPath.Trim().Trim('"'));
        projectDir = Path.GetFullPath(projectDir.Trim().Trim('"'));

        if (!File.Exists(targetPath))
            return Fail($"Target assembly not found: {targetPath}");

        string targetDir = Path.GetDirectoryName(targetPath)!;
        Assembly? ResolveFromTargetDir(object? sender, ResolveEventArgs args)
        {
            try
            {
                string simpleName = new AssemblyName(args.Name).Name ?? string.Empty;
                string candidate = Path.Combine(targetDir, simpleName + ".dll");
                return File.Exists(candidate) ? Assembly.LoadFrom(candidate) : null;
            }
            catch
            {
                return null;
            }
        }
        Assembly? ResolveFromTargetDirAlc(AssemblyLoadContext context, AssemblyName name)
        {
            try
            {
                string simpleName = name.Name ?? string.Empty;
                string candidate = Path.Combine(targetDir, simpleName + ".dll");
                return File.Exists(candidate) ? context.LoadFromAssemblyPath(candidate) : null;
            }
            catch
            {
                return null;
            }
        }
        try
        {
            AppDomain.CurrentDomain.AssemblyResolve += ResolveFromTargetDir;
            AssemblyLoadContext.Default.Resolving += ResolveFromTargetDirAlc;
            Assembly appAssembly;
            try
            {
                appAssembly = Assembly.LoadFrom(targetPath);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Failed to load assembly: {ex.Message}");
                return 1;
            }

            HashSet<string> uniqueElements = await CollectUniqueElementsFromRenderedComponents(appAssembly, cancellationToken).ConfigureAwait(false);

            string tailwindDir = Path.Combine(projectDir, TailwindDirName);
            if (!Directory.Exists(tailwindDir))
            {
                Directory.CreateDirectory(tailwindDir);
            }

            string generatedPath = Path.Combine(tailwindDir, GeneratedContentFileName);

            // Always write TailwindElements.txt so the file exists (Tailwind content scan); one line per unique element.
            var lines = new List<string> { "/* Generated by Soenneker.Quark.Gen.Tailwind BuildTasks - do not edit */" };
            foreach (string element in uniqueElements.OrderBy(e => e, StringComparer.Ordinal))
                lines.Add(element);
            string content = string.Join(Environment.NewLine, lines);
            await File.WriteAllTextAsync(generatedPath, content, Encoding.UTF8, cancellationToken).ConfigureAwait(false);

            if (uniqueElements.Count == 0)
                return 0; // No elements to scan; skip Tailwind CLI, file was still written

            string configPath = Path.Combine(tailwindDir, "tailwind.config.js");
            if (File.Exists(configPath))
                EnsureGeneratedContentInConfig(configPath, GeneratedContentFileName);

            string inputCss = Path.Combine(tailwindDir, "input.css");
            string outputCss = _commandLineArgsUtil.TryGet("--tailwindOutput", out string? outPath) && !string.IsNullOrWhiteSpace(outPath)
                ? outPath.Trim().Trim('"')
                : DefaultTailwindOutputRelative;

            if (!File.Exists(inputCss))
                return Fail($"Tailwind input not found: {inputCss}");

            int exitCode = await RunTailwindCli(tailwindDir, configPath, inputCss, outputCss, cancellationToken).ConfigureAwait(false);
            if (exitCode != 0)
            {
                Console.Error.WriteLine($"Tailwind CLI exited with code {exitCode}. {GeneratedContentFileName} was written; ensure Node/npx and @tailwindcss/cli are available to compile CSS.");
                return 0; // Do not fail the build; the generated file was written successfully.
            }
            return 0;
        }
        finally
        {
            AppDomain.CurrentDomain.AssemblyResolve -= ResolveFromTargetDir;
            AssemblyLoadContext.Default.Resolving -= ResolveFromTargetDirAlc;
        }
    }

    /// <summary>Discovers all Blazor components in the assembly, renders each to HTML via ComponentHtmlRenderer, and extracts unique elements (tag + class) per line.</summary>
    private static async Task<HashSet<string>> CollectUniqueElementsFromRenderedComponents(Assembly assembly, CancellationToken cancellationToken)
    {
        List<Type> componentTypes = DiscoverComponentTypes(assembly);
        if (componentTypes.Count == 0)
            return [];

        IServiceProvider serviceProvider = BlazorRenderServiceProvider.Create();
        var uniqueElements = new HashSet<string>(StringComparer.Ordinal);

        await using (var renderer = new ComponentHtmlRenderer(serviceProvider, disposeServiceProvider: false))
        {
            foreach (Type componentType in componentTypes)
            {
                cancellationToken.ThrowIfCancellationRequested();

                string? html = null;
                try
                {
                    html = await renderer.RenderToHtml(componentType).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    // Fallback: try with minimal service provider for components we can't register (e.g. app-specific DI).
                    try
                    {
                        IServiceProvider minimalProvider = BlazorRenderServiceProvider.CreateMinimal();
                        await using (var minimalRenderer = new ComponentHtmlRenderer(minimalProvider, disposeServiceProvider: true))
                        {
                            html = await minimalRenderer.RenderToHtml(componentType).ConfigureAwait(false);
                        }
                    }
                    catch (Exception minimalEx)
                    {
                        // Skip components that fail with both full and minimal provider.
                        Console.WriteLine($"Skipped {componentType.FullName}: {ex.Message}");
                    }
                }

                if (!string.IsNullOrEmpty(html))
                {
                    foreach (string element in ExtractUniqueElementsFromHtml(html))
                        uniqueElements.Add(element);
                }
            }
        }

        return uniqueElements;
    }

    /// <summary>Finds all types in the assembly that implement IComponent (Blazor components).</summary>
    private static List<Type> DiscoverComponentTypes(Assembly assembly)
    {
        Type componentBaseType = typeof(ComponentBase);
        Type iComponentType = typeof(IComponent);
        var list = new List<Type>();

        try
        {
            foreach (Type type in assembly.GetExportedTypes())
            {
                if (type.IsAbstract || type.IsInterface)
                    continue;
                if (!componentBaseType.IsAssignableFrom(type) && !iComponentType.IsAssignableFrom(type))
                    continue;
                if (type.Assembly != assembly)
                    continue; // Only components defined in the app assembly, not dependencies
                list.Add(type);
            }
        }
        catch (ReflectionTypeLoadException ex)
        {
            Console.Error.WriteLine($"Could not load some types from assembly: {ex.Message}");
        }

        return list;
    }

    /// <summary>Extracts unique elements from HTML (tag + normalized class). Each yielded string is one full element line, e.g. &lt;div class="col col-md-10"&gt;&lt;/div&gt;.</summary>
    private static IEnumerable<string> ExtractUniqueElementsFromHtml(string html)
    {
        foreach (Match m in ElementWithClassRegex.Matches(html))
        {
            string tag = m.Groups[1].Value;
            string classValue = m.Groups[2].Value;
            if (string.IsNullOrWhiteSpace(classValue))
                continue;
            // Normalize: trim, collapse whitespace, sort so "col-md-10 col" and "col col-md-10" are the same element.
            string normalizedClasses = string.Join(" ", classValue
                .Split((char[]?)[' ', '\t', '\n', '\r'], StringSplitOptions.RemoveEmptyEntries)
                .Select(s => s.Trim())
                .Where(s => s.Length > 0)
                .OrderBy(s => s, StringComparer.Ordinal));
            if (normalizedClasses.Length == 0)
                continue;
            yield return $"<{tag} class=\"{normalizedClasses}\"></{tag}>";
        }
    }

    private static void EnsureGeneratedContentInConfig(string configPath, string generatedFileName)
    {
        string text = File.ReadAllText(configPath);
        if (text.Contains(generatedFileName, StringComparison.Ordinal))
            return;

        var marker = "content:";
        int idx = text.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
        if (idx < 0)
            return;
        int afterContent = idx + marker.Length;
        int bracket = text.IndexOf('[', afterContent);
        if (bracket < 0)
            return;
        int insertAt = bracket + 1;
        var entry = $"./{generatedFileName}";
        var toInsert = $" \"{entry}\",";
        text = text.Insert(insertAt, toInsert);
        File.WriteAllText(configPath, text);
    }

    private async Task<int> RunTailwindCli(string workingDir, string configPath, string inputCss, string outputCss, CancellationToken cancellationToken)
    {
        string inputFileName = Path.GetFileName(inputCss);
        bool hasConfig = File.Exists(configPath);
        string? configFileName = hasConfig ? Path.GetFileName(configPath) : null;

        var argList = new List<string> { "@tailwindcss/cli" };
        if (hasConfig && !string.IsNullOrEmpty(configFileName))
        {
            argList.Add("-c");
            argList.Add(configFileName);
        }
        argList.Add("-i");
        argList.Add(inputFileName);
        argList.Add("-o");
        argList.Add(outputCss);

        string arguments = string.Join(" ", argList.Select(a => a.Contains(' ') ? $"\"{a}\"" : a));
        string npxPath = _nodeUtil.GetNpxPath();

        try
        {
            await _processUtil.Start(
                npxPath,
                workingDir,
                arguments,
                admin: false,
                waitForExit: true,
                timeout: null,
                log: true,
                environmentalVars: null,
                cancellationToken).ConfigureAwait(false);
            return 0;
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("exited with code"))
        {
            Console.Error.WriteLine($"{GeneratedContentFileName} was written; ensure Node/npx and @tailwindcss/cli are available to compile CSS.");
            return 0;
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("Failed to start"))
        {
            Console.Error.WriteLine($"Failed to start Tailwind CLI: {ex.Message}. Tried npx at: {npxPath}. Ensure Node is installed.");
            return 1;
        }
        catch (OperationCanceledException)
        {
            return 1;
        }
    }

    private static int Fail(string message)
    {
        Console.Error.WriteLine(message);
        return 1;
    }
}
