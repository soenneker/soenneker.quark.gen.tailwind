using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Soenneker.Quark.Gen.Tailwind.BuildTasks.Abstract;

namespace Soenneker.Quark.Gen.Tailwind.BuildTasks;

///<inheritdoc cref="ITailwindGeneratorRunner"/>
public sealed class TailwindGeneratorRunner : ITailwindGeneratorRunner
{
    private const string GeneratedContentFileName = "GeneratedTailwind.razor";
    private const string TailwindDirName = "tailwind";
    private const string DefaultTailwindOutputRelative = "../wwwroot/css/tailwind.css";

    public async ValueTask<int> Run(string[] args, CancellationToken cancellationToken)
    {
        var map = ParseArgs(args);
        if (!map.TryGetValue("--targetPath", out var targetPath) || string.IsNullOrWhiteSpace(targetPath))
            return Fail("Missing required --targetPath");
        if (!map.TryGetValue("--projectDir", out var projectDir) || string.IsNullOrWhiteSpace(projectDir))
            return Fail("Missing required --projectDir");

        targetPath = Path.GetFullPath(targetPath.Trim().Trim('"'));
        projectDir = Path.GetFullPath(projectDir.Trim().Trim('"'));

        if (!File.Exists(targetPath))
            return Fail($"Target assembly not found: {targetPath}");

        // 1) Analyze Blazor files and collect Tailwind classes from component usage
        var classes = BlazorTailwindClassCollector.CollectTailwindClassesFromBlazor(projectDir);
        if (classes.Count == 0)
            return 0; // Nothing to emit; Tailwind can still run with existing content

        // 2) Resolve tailwind directory (projectDir/tailwind or projectDir if no tailwind subdir)
        var tailwindDir = Path.Combine(projectDir, TailwindDirName);
        if (!Directory.Exists(tailwindDir))
            tailwindDir = projectDir;

        var generatedPath = Path.Combine(tailwindDir, GeneratedContentFileName);

        // 3) Write generated content file so Tailwind CLI will include these classes
        var classList = string.Join(" ", classes.OrderBy(c => c, StringComparer.Ordinal));
        var content = $"@* Generated by Soenneker.Quark.Gen.Tailwind BuildTasks - do not edit *@\n<div class=\"{classList}\"></div>\n";
        await File.WriteAllTextAsync(generatedPath, content, Encoding.UTF8, cancellationToken).ConfigureAwait(false);

        // 4) Ensure tailwind config content array includes the generated file
        var configPath = Path.Combine(tailwindDir, "tailwind.config.js");
        if (File.Exists(configPath))
            EnsureGeneratedContentInConfig(configPath, GeneratedContentFileName);

        // 5) Run Tailwind CLI to compile CSS (using the class list via the generated file)
        var inputCss = Path.Combine(tailwindDir, "input.css");
        var outputCss = map.TryGetValue("--tailwindOutput", out var outPath) && !string.IsNullOrWhiteSpace(outPath)
            ? outPath.Trim().Trim('"')
            : DefaultTailwindOutputRelative;

        if (!File.Exists(inputCss))
            return Fail($"Tailwind input not found: {inputCss}");

        var exitCode = await RunTailwindCli(tailwindDir, configPath, inputCss, outputCss, cancellationToken).ConfigureAwait(false);
        if (exitCode != 0)
        {
            Console.Error.WriteLine($"Tailwind CLI exited with code {exitCode}. GeneratedTailwind.razor was written; ensure Node/npx and @tailwindcss/cli are available to compile CSS.");
            return 0; // Do not fail the build; the generated file was written successfully.
        }
        return 0;
    }

    private static void EnsureGeneratedContentInConfig(string configPath, string generatedFileName)
    {
        var text = File.ReadAllText(configPath);
        var entry = $"./{generatedFileName}";
        if (text.Contains(generatedFileName, StringComparison.Ordinal))
            return;

        // Insert generated file as first content entry: content: [ -> content: [ "./GeneratedTailwind.razor",
        var marker = "content:";
        var idx = text.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
        if (idx < 0)
            return;
        var afterContent = idx + marker.Length;
        var bracket = text.IndexOf('[', afterContent);
        if (bracket < 0)
            return;
        var insertAt = bracket + 1;
        var toInsert = $" \"{entry}\",";
        text = text.Insert(insertAt, toInsert);
        File.WriteAllText(configPath, text);
    }

    private static async Task<int> RunTailwindCli(string workingDir, string configPath, string inputCss, string outputCss, CancellationToken cancellationToken)
    {
        var inputFileName = Path.GetFileName(inputCss);
        var hasConfig = File.Exists(configPath);
        var configFileName = hasConfig ? Path.GetFileName(configPath) : null;

        var argList = new List<string> { "@tailwindcss/cli" };
        if (hasConfig && !string.IsNullOrEmpty(configFileName))
        {
            argList.Add("-c");
            argList.Add(configFileName);
        }
        argList.Add("-i");
        argList.Add(inputFileName);
        argList.Add("-o");
        argList.Add(outputCss);

        var psi = new ProcessStartInfo
        {
            FileName = "npx",
            WorkingDirectory = workingDir,
            UseShellExecute = false,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            CreateNoWindow = true
        };
        foreach (var a in argList)
            psi.ArgumentList.Add(a);

        using var process = new Process { StartInfo = psi };
        var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);
        process.EnableRaisingEvents = true;
        process.Exited += (_, _) => tcs.TrySetResult(process.ExitCode);

        try
        {
            process.Start();
        }
        catch (Exception e)
        {
            Console.Error.WriteLine($"Failed to start Tailwind CLI: {e.Message}. Ensure Node/npx and @tailwindcss/cli are available.");
            return 1;
        }

        _ = Task.Run(async () =>
        {
            try
            {
                var stdout = await process.StandardOutput.ReadToEndAsync(cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrEmpty(stdout))
                    Console.WriteLine(stdout);
            }
            catch { /* ignore */ }
        }, cancellationToken);
        _ = Task.Run(async () =>
        {
            try
            {
                var stderr = await process.StandardError.ReadToEndAsync(cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrEmpty(stderr))
                    Console.Error.WriteLine(stderr);
            }
            catch { /* ignore */ }
        }, cancellationToken);

        using (cancellationToken.Register(() => tcs.TrySetCanceled()))
        {
            try
            {
                return await tcs.Task.ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                try { process.Kill(entireProcessTree: true); } catch { }
                return 1;
            }
        }
    }

    private static Dictionary<string, string> ParseArgs(string[] args)
    {
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        for (var i = 0; i < args.Length; i++)
        {
            if (args[i].StartsWith("--", StringComparison.Ordinal) && i + 1 < args.Length)
            {
                map[args[i]] = args[i + 1];
                i++;
            }
        }
        return map;
    }

    private static int Fail(string message)
    {
        Console.Error.WriteLine(message);
        return 1;
    }
}
