using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Soenneker.Quark.Gen.Tailwind.BuildTasks.Abstract;

namespace Soenneker.Quark.Gen.Tailwind.BuildTasks;

///<inheritdoc cref="ITailwindGeneratorRunner"/>
public sealed class TailwindGeneratorRunner : ITailwindGeneratorRunner
{
    private const string GeneratedContentFileName = "TailwindClasses.txt";
    private const string TailwindDirName = "tailwind";
    /// <summary>Output path for Tailwind CLI relative to the tailwind directory. Override with --tailwindOutput or MSBuild TailwindOutput.</summary>
    private const string DefaultTailwindOutputRelative = "../wwwroot/css/quark-tailwind.css";

    public async ValueTask<int> Run(string[] args, CancellationToken cancellationToken)
    {
        var map = ParseArgs(args);
        if (!map.TryGetValue("--targetPath", out var targetPath) || string.IsNullOrWhiteSpace(targetPath))
            return Fail("Missing required --targetPath");
        if (!map.TryGetValue("--projectDir", out var projectDir) || string.IsNullOrWhiteSpace(projectDir))
            return Fail("Missing required --projectDir");

        targetPath = Path.GetFullPath(targetPath.Trim().Trim('"'));
        projectDir = Path.GetFullPath(projectDir.Trim().Trim('"'));

        if (!File.Exists(targetPath))
            return Fail($"Target assembly not found: {targetPath}");

        Assembly? appAssembly = null;
        try { appAssembly = Assembly.LoadFrom(targetPath); } catch { /* e.g. native deps */ }
        // Scan Razor for component tags (e.g. <Column ...>) and their attributes; resolve component type by tag name, set param, call GetClasses()
        var usages = CollectComponentTagUsagesFromProject(projectDir);
        var classes = appAssembly != null ? Soenneker.Quark.TailwindClassCatalog.GetClassesFromComponentUsages(appAssembly, usages) : new HashSet<string>();
        if (classes.Count == 0)
            return 0; // Nothing to emit; Tailwind can still run with existing content

        // 2) Resolve tailwind directory (projectDir/tailwind or projectDir if no tailwind subdir)
        var tailwindDir = Path.Combine(projectDir, TailwindDirName);
        if (!Directory.Exists(tailwindDir))
            tailwindDir = projectDir;

        var generatedPath = Path.Combine(tailwindDir, GeneratedContentFileName);

        // 3) Write generated file: one class name per line (no leading dot, no {}, no escaping)
        var sb = new StringBuilder();
        sb.AppendLine("/* Generated by Soenneker.Quark.Gen.Tailwind BuildTasks - do not edit */");
        foreach (var c in classes.OrderBy(c => c, StringComparer.Ordinal))
            sb.AppendLine(c);
        await File.WriteAllTextAsync(generatedPath, sb.ToString(), Encoding.UTF8, cancellationToken).ConfigureAwait(false);

        // 4) Ensure tailwind config content array includes the generated file
        var configPath = Path.Combine(tailwindDir, "tailwind.config.js");
        if (File.Exists(configPath))
            EnsureGeneratedContentInConfig(configPath, GeneratedContentFileName);

        // 5) Run Tailwind CLI to compile CSS (using the class list via the generated file)
        var inputCss = Path.Combine(tailwindDir, "input.css");
        var outputCss = map.TryGetValue("--tailwindOutput", out var outPath) && !string.IsNullOrWhiteSpace(outPath)
            ? outPath.Trim().Trim('"')
            : DefaultTailwindOutputRelative;

        if (!File.Exists(inputCss))
            return Fail($"Tailwind input not found: {inputCss}");

        var exitCode = await RunTailwindCli(tailwindDir, configPath, inputCss, outputCss, cancellationToken).ConfigureAwait(false);
        if (exitCode != 0)
        {
            Console.Error.WriteLine($"Tailwind CLI exited with code {exitCode}. TailwindClasses.txt was written; ensure Node/npx and @tailwindcss/cli are available to compile CSS.");
            return 0; // Do not fail the build; the generated file was written successfully.
        }
        return 0;
    }

    /// <summary>Scans project for component tags (PascalCase) and extracts (tagName, paramName, expression) from each tag's attributes. No param-name list needed â€” we parse the tag and its attributes.</summary>
    private static List<(string TagName, string ParamName, string Expression)> CollectComponentTagUsagesFromProject(string projectDir)
    {
        var usages = new List<(string, string, string)>();
        // Opening tag: <TagName ...attrs...> where TagName is PascalCase
        var tagRegex = new Regex(@"<([A-Z][a-zA-Z0-9]*)\s+([^>]*)>", RegexOptions.CultureInvariant);
        var attrRegex = new Regex(@"(\w+)\s*=\s*[""']([^""']+)[""']", RegexOptions.CultureInvariant);

        foreach (var path in Directory.EnumerateFiles(projectDir, "*.razor", SearchOption.AllDirectories)
            .Concat(Directory.EnumerateFiles(projectDir, "*.cshtml", SearchOption.AllDirectories)))
        {
            try
            {
                var text = File.ReadAllText(path);
                foreach (Match tagMatch in tagRegex.Matches(text))
                {
                    var tagName = tagMatch.Groups[1].Value;
                    var attrs = tagMatch.Groups[2].Value;
                    foreach (Match attrMatch in attrRegex.Matches(attrs))
                    {
                        var paramName = attrMatch.Groups[1].Value;
                        var value = attrMatch.Groups[2].Value.Trim();
                        value = value.StartsWith("@(", StringComparison.Ordinal) && value.EndsWith(")", StringComparison.Ordinal)
                            ? value.Substring(2, value.Length - 3).Trim()
                            : value;
                        if (value.Length > 0 && value.IndexOf('.') >= 0)
                            usages.Add((tagName, paramName, value));
                    }
                }
            }
            catch { /* skip unreadable files */ }
        }

        return usages;
    }

    private static void EnsureGeneratedContentInConfig(string configPath, string generatedFileName)
    {
        var text = File.ReadAllText(configPath);
        var entry = $"./{generatedFileName}";
        if (text.Contains(generatedFileName, StringComparison.Ordinal))
            return;

        // Insert generated .txt as first content entry so CLI scans it for class names: content: [ -> content: [ "./TailwindClasses.txt",
        var marker = "content:";
        var idx = text.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
        if (idx < 0)
            return;
        var afterContent = idx + marker.Length;
        var bracket = text.IndexOf('[', afterContent);
        if (bracket < 0)
            return;
        var insertAt = bracket + 1;
        var toInsert = $" \"{entry}\",";
        text = text.Insert(insertAt, toInsert);
        File.WriteAllText(configPath, text);
    }

    /// <summary>Resolve full path to npx so the build can find it when PATH is not set (e.g. Visual Studio).</summary>
    private static string ResolveNpxPath()
    {
        // Prefer npx from PATH if it runs (e.g. "npx" or "npx.cmd")
        try
        {
            var pathEnv = Environment.GetEnvironmentVariable("PATH");
            if (!string.IsNullOrEmpty(pathEnv))
            {
                var sep = Path.PathSeparator;
                foreach (var dir in pathEnv.Split(sep, StringSplitOptions.RemoveEmptyEntries))
                {
                    if (string.IsNullOrWhiteSpace(dir)) continue;
                    var dirTrim = dir.Trim();
                    foreach (var name in new[] { "npx.cmd", "npx.exe", "npx" })
                    {
                        var full = Path.Combine(dirTrim, name);
                        if (File.Exists(full))
                            return full;
                    }
                }
            }
        }
        catch { /* ignore */ }

        // Windows: common Node install locations (build often runs without user PATH)
        var programFiles = Environment.GetEnvironmentVariable("ProgramFiles");
        var localAppData = Environment.GetEnvironmentVariable("LOCALAPPDATA");
        var appData = Environment.GetEnvironmentVariable("APPDATA");
        var candidates = new List<string>();
        if (!string.IsNullOrEmpty(programFiles))
        {
            candidates.Add(Path.Combine(programFiles, "nodejs", "npx.cmd"));
            candidates.Add(Path.Combine(programFiles, "nodejs", "npx.exe"));
        }
        if (!string.IsNullOrEmpty(localAppData))
        {
            candidates.Add(Path.Combine(localAppData, "Programs", "node", "npx.cmd"));
            candidates.Add(Path.Combine(localAppData, "Programs", "node", "npx.exe"));
        }
        if (!string.IsNullOrEmpty(appData))
            candidates.Add(Path.Combine(appData, "npm", "npx.cmd"));

        foreach (var c in candidates)
        {
            if (!string.IsNullOrEmpty(c) && File.Exists(c))
                return c;
        }

        return "npx"; // fallback: hope PATH is set
    }

    private static async Task<int> RunTailwindCli(string workingDir, string configPath, string inputCss, string outputCss, CancellationToken cancellationToken)
    {
        var inputFileName = Path.GetFileName(inputCss);
        var hasConfig = File.Exists(configPath);
        var configFileName = hasConfig ? Path.GetFileName(configPath) : null;

        var argList = new List<string> { "@tailwindcss/cli" };
        if (hasConfig && !string.IsNullOrEmpty(configFileName))
        {
            argList.Add("-c");
            argList.Add(configFileName);
        }
        argList.Add("-i");
        argList.Add(inputFileName);
        argList.Add("-o");
        argList.Add(outputCss);

        var npxPath = ResolveNpxPath();
        var psi = new ProcessStartInfo
        {
            FileName = npxPath,
            WorkingDirectory = workingDir,
            UseShellExecute = false,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            CreateNoWindow = true
        };
        foreach (var a in argList)
            psi.ArgumentList.Add(a);

        using var process = new Process { StartInfo = psi };
        var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);
        process.EnableRaisingEvents = true;
        process.Exited += (_, _) => tcs.TrySetResult(process.ExitCode);

        try
        {
            process.Start();
        }
        catch (Exception e)
        {
            Console.Error.WriteLine($"Failed to start Tailwind CLI: {e.Message}. Tried npx at: {npxPath}. Ensure Node is installed (e.g. Program Files\\nodejs or run from a shell where 'npx' is in PATH).");
            return 1;
        }

        _ = Task.Run(async () =>
        {
            try
            {
                var stdout = await process.StandardOutput.ReadToEndAsync(cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrEmpty(stdout))
                    Console.WriteLine(stdout);
            }
            catch { /* ignore */ }
        }, cancellationToken);
        _ = Task.Run(async () =>
        {
            try
            {
                var stderr = await process.StandardError.ReadToEndAsync(cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrEmpty(stderr))
                    Console.Error.WriteLine(stderr);
            }
            catch { /* ignore */ }
        }, cancellationToken);

        using (cancellationToken.Register(() => tcs.TrySetCanceled()))
        {
            try
            {
                return await tcs.Task.ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                try { process.Kill(entireProcessTree: true); } catch { }
                return 1;
            }
        }
    }

    private static Dictionary<string, string> ParseArgs(string[] args)
    {
        var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        for (var i = 0; i < args.Length; i++)
        {
            if (args[i].StartsWith("--", StringComparison.Ordinal) && i + 1 < args.Length)
            {
                map[args[i]] = args[i + 1];
                i++;
            }
        }
        return map;
    }

    private static int Fail(string message)
    {
        Console.Error.WriteLine(message);
        return 1;
    }
}
